const Bin = require('../models/bin');
// const WebSocket = require('ws'); // No longer needed if using socket.io

// Helper function to broadcast messages via Socket.IO
const emitBinUpdate = async (req, eventName, data) => {
    const io = req.app.get('io'); // Get the socket.io instance attached to the app
    if (io) {
        try {
            const allBins = await Bin.find({}); // Fetch updated list of bins to send
            const systemStats = await Bin.getSystemStats(); // Fetch updated system stats
            // Emit to all connected clients
            io.emit(eventName, { payload: allBins, singleBin: data, systemStats: systemStats });
            console.log(`Socket.IO: Emitted '${eventName}' update.`);
        } catch (dbError) {
            console.error('Error fetching bins/stats for Socket.IO emit:', dbError);
        }
    } else {
        console.warn('Socket.IO server (io) not available on app object.');
    }
};


// Get the status of all bins
exports.getAllBins = async (req, res) => {
    try {
        const bins = await Bin.find();
        res.status(200).json(bins); // Changed from { success: true, data: bins } for consistency with dashboard's fetch
    } catch (error) {
        console.error('Error retrieving bins:', error);
        res.status(500).json({ message: 'Error retrieving bins', error: error.message });
    }
};

// Get the status of a specific bin by binId (not _id)
exports.getBinStatus = async (req, res) => {
    const { binId } = req.params;
    try {
        const bin = await Bin.findOne({ binId });
        if (!bin) {
            return res.status(404).json({ message: 'Bin not found' });
        }
        res.status(200).json(bin); // Changed from { success: true, data: bin }
    } catch (error) {
        console.error('Error retrieving bin:', error);
        res.status(500).json({ message: 'Error retrieving bin', error: error.message });
    }
};

// Get the fill level history of a bin (stub, implement as needed)
exports.getBinHistory = async (req, res) => {
    res.status(501).json({ message: 'Bin history not implemented.' });
};

// Update the fill level of a specific bin
exports.updateBin = async (req, res) => {
    const { binId } = req.params;
    const { fillLevel, batteryLevel, temperature, sensorStatus, lastEmptied, coordinates, metadata } = req.body;

    try {
        const bin = await Bin.findOne({ binId });
        if (!bin) {
            return res.status(404).json({ message: 'Bin not found' });
        }

        let updatedBin = bin; // Start with the existing bin

        // Use updateFillLevel method if fillLevel is provided
        if (fillLevel !== undefined) {
            if (typeof fillLevel !== 'number' || fillLevel < 0 || fillLevel > 100) {
                return res.status(400).json({ message: 'Fill level must be a number between 0 and 100.' });
            }
            await bin.updateFillLevel(fillLevel); // This also saves the bin
            updatedBin = bin; // bin object is now updated
        }

        // Handle other fields directly if they are provided and fillLevel wasn't the only update
        const otherUpdateFields = {};
        if (batteryLevel !== undefined) otherUpdateFields.batteryLevel = batteryLevel;
        if (temperature !== undefined) otherUpdateFields.temperature = temperature;
        if (sensorStatus !== undefined) otherUpdateFields.sensorStatus = sensorStatus;
        if (lastEmptied !== undefined) otherUpdateFields.lastEmptied = lastEmptied;
        if (coordinates !== undefined) otherUpdateFields.coordinates = coordinates;
        if (metadata !== undefined) otherUpdateFields.metadata = { ...bin.metadata, ...metadata };

        if (Object.keys(otherUpdateFields).length > 0) {
            // Apply other updates and save if they exist
            Object.assign(bin, otherUpdateFields);
            await bin.save(); // Save again if there were other updates
            updatedBin = bin; // Ensure updatedBin reflects all changes
        }

        // Emit real-time update using socket.io
        await emitBinUpdate(req, 'binUpdated', updatedBin);

        res.status(200).json(updatedBin); // Changed from { success: true, data: updatedBin }
    } catch (error) {
        console.error('Error updating bin:', error);
        res.status(500).json({ message: 'Error updating bin', error: error.message });
    }
};

// Add a new bin
exports.createBin = async (req, res) => {
    // ðŸš€ MODIFIED: binId is no longer destructured from req.body
    const { location, capacity, fillLevel, batteryLevel, temperature, sensorStatus, lastEmptied, coordinates, metadata } = req.body;

    // Basic validation for fields expected from frontend
    if (!location || !capacity) {
        return res.status(400).json({ message: 'Location and capacity are required.' });
    }

    try {
        // binId will be generated by the pre-save hook in the Bin model
        const newBin = new Bin({
            location: location.trim(),
            capacity: capacity,
            // Provide defaults for other fields if not sent by frontend
            fillLevel: fillLevel || 0,
            batteryLevel: batteryLevel || 100,
            temperature: temperature || 20,
            sensorStatus: sensorStatus || 'active',
            lastEmptied: lastEmptied || new Date(),
            coordinates: coordinates || {},
            metadata: {
                ...metadata,
                installationDate: new Date()
            }
        });

        await newBin.save(); // binId will be generated here

        // Emit real-time update using socket.io
        await emitBinUpdate(req, 'binAdded', newBin);

        res.status(201).json(newBin); // Changed from { success: true, message: '...', data: newBin }
    } catch (error) {
        console.error('Error creating bin:', error);
        // Handle unique constraint error for binId if it somehow gets duplicated
        if (error.code === 11000) {
            return res.status(409).json({ message: 'A bin with this generated ID might already exist. Please try again.' });
        }
        res.status(500).json({ message: 'Error creating bin', error: error.message });
    }
};

// Delete a bin
exports.deleteBin = async (req, res) => {
    const { binId } = req.params; // Use binId from params
    try {
        const deletedBin = await Bin.findOneAndDelete({ binId }); // Find by binId
        if (!deletedBin) {
            return res.status(404).json({ message: 'Bin not found.' });
        }

        // Emit real-time update using socket.io
        await emitBinUpdate(req, 'binRemoved', { binId: binId }); // Use 'binRemoved' event

        res.status(200).json({ message: 'Bin deleted successfully.', data: deletedBin });
    } catch (error) {
        console.error('Error deleting bin:', error);
        res.status(500).json({ message: 'Error deleting bin', error: error.message });
    }
};

// Mark bin as emptied
exports.markBinEmptied = async (req, res) => {
    const { binId } = req.params;
    try {
        const bin = await Bin.findOne({ binId });
        if (!bin) {
            return res.status(404).json({ message: 'Bin not found' });
        }

        bin.fillLevel = 0;
        bin.lastEmptied = new Date();
        bin.lastUpdated = new Date();

        await bin.save();

        // Emit real-time update using socket.io
        await emitBinUpdate(req, 'binEmptied', bin);

        res.status(200).json({ message: 'Bin marked as emptied.', data: bin });
    } catch (error) {
        console.error('Error marking bin as emptied:', error);
        res.status(500).json({ message: 'Error marking bin as emptied', error: error.message });
    }
};